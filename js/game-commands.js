// ============================================
// GAME COMMANDS - Single Source of Truth
// All game commands defined here once.
// Skulpt module source is generated by skulpt-bridge.js
// ============================================

(function() {
    'use strict';

    // ========== HELPER REFERENCES ==========
    // Use CommandHelpers module for shared utilities
    
    function findObjectAt(x, y, type) {
        return window.CommandHelpers ? CommandHelpers.findObjectAt(x, y, type) : null;
    }

    function updateInventoryDisplay() {
        if (window.CommandHelpers) CommandHelpers.updateInventoryDisplay();
    }
    
    function updateBackpackDisplay() {
        if (window.CommandHelpers) CommandHelpers.updateBackpackDisplay();
    }

    function getTargetPosition() {
        return window.CommandHelpers ? CommandHelpers.getTargetPosition() : { px: 0, py: 0, targetX: 0, targetY: 0 };
    }

    function getAnimationDuration(fraction) {
        return window.CommandHelpers ? CommandHelpers.getAnimationDuration(fraction) : 300;
    }

    // ========== COMMAND DEFINITIONS ==========
    // Single source of truth: metadata + execute function
    // Both JS callers and Skulpt use these definitions
    
    var GameCommands = {
        move_forward: {
            args: ['steps'],
            defaults: { steps: 1 },
            countsAsMultiple: true,
            execute: async function(steps) {
                steps = parseInt(steps) || 1;
                var moved = 0;
                
                for (var i = 0; i < steps; i++) {
                    var pos = gameState.playerPos;
                    var x = pos.x, y = pos.y;
                    var newX = Math.floor(x);
                    var newY = Math.floor(y);
                    
                    switch (gameState.playerDirection) {
                        case 'up': newY--; break;
                        case 'down': newY++; break;
                        case 'left': newX--; break;
                        case 'right': newX++; break;
                    }
                    
                    if (canMoveTo(newX, newY)) {
                        await animateMove(x, y, newX, newY, gameState.playerDirection);
                        moved++;
                    } else {
                        playBumpSound();
                        break;
                    }
                }
                
                if (window.TestRunner) {
                    TestRunner.evaluate();
                } else {
                    checkWinCondition();
                }
                return moved;
            }
        },

        turn_left: {
            args: ['times'],
            defaults: { times: 1 },
            countsAsMultiple: true,
            execute: async function(times) {
                times = parseInt(times) || 1;
                var directions = ['up', 'left', 'down', 'right'];
                
                for (var i = 0; i < times; i++) {
                    var currentIndex = directions.indexOf(gameState.playerDirection);
                    gameState.playerDirection = directions[(currentIndex + 1) % 4];
                    
                    await new Promise(function(resolve) {
                        setTimeout(function() { render(); resolve(); }, getAnimationDuration(0.5));
                    });
                }
                
                return times;
            }
        },

        turn_right: {
            args: ['times'],
            defaults: { times: 1 },
            countsAsMultiple: true,
            execute: async function(times) {
                times = parseInt(times) || 1;
                var directions = ['up', 'right', 'down', 'left'];
                
                for (var i = 0; i < times; i++) {
                    var currentIndex = directions.indexOf(gameState.playerDirection);
                    gameState.playerDirection = directions[(currentIndex + 1) % 4];
                    
                    await new Promise(function(resolve) {
                        setTimeout(function() { render(); resolve(); }, getAnimationDuration(0.5));
                    });
                }
                
                return times;
            }
        },

        // ========== SIMPLIFIED ALIASES ==========
        // Short command names for beginners
        
        forward: {
            args: ['steps'],
            defaults: { steps: 1 },
            countsAsMultiple: true,
            aliasOf: 'move_forward'
        },

        left: {
            args: ['times'],
            defaults: { times: 1 },
            countsAsMultiple: true,
            aliasOf: 'turn_left'
        },

        right: {
            args: ['times'],
            defaults: { times: 1 },
            countsAsMultiple: true,
            aliasOf: 'turn_right'
        },

        push: {
            execute: async function() {
                var pos = getTargetPosition();
                var object = findObjectAt(pos.targetX, pos.targetY, 'pushable');
                
                if (object) {
                    var newX = pos.targetX, newY = pos.targetY;
                    switch (gameState.playerDirection) {
                        case 'up': newY--; break;
                        case 'down': newY++; break;
                        case 'left': newX--; break;
                        case 'right': newX++; break;
                    }
                    
                    if (canMoveTo(newX, newY)) {
                        object.x = newX;
                        object.y = newY;
                        await render();
                    }
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        speak: {
            args: ['message'],
            defaults: { message: '' },
            execute: async function(message) {
                if (!message) return;
                message = String(message).replace(/^["']|["']$/g, '');
                
                if (window.showGameMessage) {
                    showGameMessage(message, 'player');
                } else {
                    if (!gameState.messageLog) gameState.messageLog = [];
                    gameState.messageLog.push(message);
                    
                    var messagePanel = document.getElementById('message-panel');
                    if (messagePanel) {
                        var msgDiv = document.createElement('div');
                        msgDiv.className = 'message-item message-player';
                        msgDiv.textContent = message;
                        messagePanel.appendChild(msgDiv);
                        messagePanel.scrollTop = messagePanel.scrollHeight;
                    }
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(1)); });
            }
        },

        collect: {
            args: ['resource'],
            defaults: { resource: 'item' },
            execute: async function(resource) {
                var guardResult = window.ProximityGuard 
                    ? ProximityGuard.check({ mode: 'self', sections: ['collectibles'] })
                    : { success: false };
                
                if (!guardResult.success && window.ProximityGuard) {
                    guardResult = ProximityGuard.check({ mode: 'forward', sections: ['collectibles'] });
                }
                
                if (guardResult.success && guardResult.element) {
                    var consumeResult = ProximityGuard.consume(guardResult.element);
                    if (consumeResult.success) {
                        playCollectSound();
                        animateCollectSparkle(guardResult.position.x, guardResult.position.y);
                        if (window.showGameMessage) showGameMessage(consumeResult.message, 'success');
                        updateInventoryDisplay();
                        await render();
                    }
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        interact: {
            args: [],
            defaults: {},
            execute: async function() {
                var px = Math.floor(gameState.playerPos.x);
                var py = Math.floor(gameState.playerPos.y);
                
                if (window.VehicleInteractionManager && VehicleInteractionManager.isBoarded()) {
                    var disembarkResult = VehicleInteractionManager.handleDisembark(gameState);
                    if (window.showGameMessage) showGameMessage(disembarkResult.message, disembarkResult.success ? 'success' : 'error');
                    if (disembarkResult.success) {
                        playInteractSound();
                        animateInteractPop(px, py);
                        await render();
                    }
                    await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                    return;
                }
                
                var adjacent = [
                    { x: px + 1, y: py },
                    { x: px, y: py - 1 },
                    { x: px, y: py + 1 },
                    { x: px - 1, y: py }
                ];
                
                for (var i = 0; i < adjacent.length; i++) {
                    var tile = adjacent[i];
                    
                    if (window.VehicleInteractionManager) {
                        var vehicleResult = VehicleInteractionManager.handleInteract(tile.x, tile.y, gameState);
                        if (vehicleResult.success) {
                            playInteractSound();
                            animateInteractPop(tile.x, tile.y);
                            if (window.showGameMessage) showGameMessage(vehicleResult.message, 'success');
                            await render();
                            await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                            return;
                        }
                    }
                    
                    if (window.ElementInteractionManager) {
                        var result = ElementInteractionManager.handleInteract(tile.x, tile.y, gameState);
                        if (result.success) {
                            playInteractSound();
                            animateInteractPop(tile.x, tile.y);
                            if (window.showGameMessage) showGameMessage(result.message, 'success');
                            await render();
                            await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                            return;
                        }
                    }
                }
                
                if (window.showGameMessage) showGameMessage('Nothing to interact with nearby', 'info');
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        water: {
            execute: async function() {
                var px = Math.floor(gameState.playerPos.x);
                var py = Math.floor(gameState.playerPos.y);
                
                if (gameState.farmPlots) {
                    var plot = gameState.farmPlots.find(function(p) { return p.x === px && p.y === py; });
                    if (plot && plot.stage === 'sprout' && !plot.watered) {
                        plot.watered = true;
                        if (window.showGameMessage) showGameMessage('Watered the sprout!', 'success');
                        await render();
                        
                        plot.timerId = setTimeout(function() {
                            if (plot.cancelled) return;
                            if (plot.stage === 'sprout' && plot.watered && gameState.farmPlots && gameState.farmPlots.includes(plot)) {
                                plot.stage = 'grown';
                                plot.timerId = null;
                                if (window.showGameMessage) showGameMessage(plot.crop + ' is ready to harvest!', 'success');
                                render();
                            }
                        }, 30000);
                        
                        await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                        return;
                    } else if (plot && plot.stage === 'dirt') {
                        if (window.showGameMessage) showGameMessage('Wait for sprout to appear first!', 'info');
                        await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                        return;
                    } else if (plot && plot.watered) {
                        if (window.showGameMessage) showGameMessage('Already watered!', 'info');
                        await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                        return;
                    }
                }
                
                if (window.showGameMessage) showGameMessage('Nothing to water here', 'info');
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        open: {
            execute: async function() {
                var pos = getTargetPosition();
                var door = findObjectAt(pos.targetX, pos.targetY, 'door');
                
                if (door) {
                    door.open = true;
                    await render();
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        close: {
            execute: async function() {
                var pos = getTargetPosition();
                var door = findObjectAt(pos.targetX, pos.targetY, 'door');
                
                if (door) {
                    door.open = false;
                    await render();
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        place: {
            args: ['item'],
            defaults: { item: null },
            execute: async function(item) {
                if (!item) return;
                var pos = getTargetPosition();
                var chest = findObjectAt(pos.targetX, pos.targetY, 'chest');
                
                if (chest) {
                    if (!chest.contents) chest.contents = [];
                    chest.contents.push(item);
                    await render();
                }
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        build: {
            args: ['elementName'],
            defaults: { elementName: null },
            execute: async function(elementName) {
                if (!elementName) {
                    if (window.showGameMessage) showGameMessage('No element specified', 'error');
                    return;
                }
                
                var elementDef = null;
                if (window.ElementInteractionManager && ElementInteractionManager.getElementDefinition) {
                    elementDef = ElementInteractionManager.getElementDefinition(elementName);
                }
                
                if (!elementDef) {
                    if (window.showGameMessage) showGameMessage('Element does not exist: ' + elementName, 'error');
                    return;
                }
                
                if (!elementDef.cost) {
                    if (window.showGameMessage) showGameMessage("Can't build that: " + elementName, 'error');
                    return;
                }
                
                var cost = elementDef.cost;
                var inventory = gameState.inventory || {};
                if (window.MissionState && MissionState.isMissionLevel) {
                    inventory = MissionState.getInventory();
                }
                
                for (var material in cost) {
                    var required = cost[material];
                    var available = inventory[material] || 0;
                    if (available < required) {
                        if (window.showGameMessage) {
                            showGameMessage('Not enough ' + material + ' (need ' + required + ', have ' + available + ')', 'error');
                        }
                        return;
                    }
                }
                
                for (var material in cost) {
                    var amount = cost[material];
                    if (window.MissionState && MissionState.isMissionLevel) {
                        MissionState.removeFromInventory(material, amount);
                        gameState.inventory = MissionState.getInventory();
                    } else {
                        if (!gameState.inventory) gameState.inventory = {};
                        gameState.inventory[material] = (gameState.inventory[material] || 0) - amount;
                        if (gameState.inventory[material] <= 0) {
                            delete gameState.inventory[material];
                        }
                    }
                }
                
                var pos = getTargetPosition();
                
                if (!gameState.builtElements) gameState.builtElements = [];
                var builtElement = {
                    type: elementName,
                    x: pos.targetX,
                    y: pos.targetY,
                    id: 'built_' + elementName + '_' + Date.now()
                };
                gameState.builtElements.push(builtElement);
                
                if (elementName === 'bridge' && gameState.mapData[pos.targetY]) {
                    gameState.mapData[pos.targetY][pos.targetX] = getTileIdByName('path');
                }
                
                updateInventoryDisplay();
                updateBackpackDisplay();
                
                if (window.MissionState && MissionState.isMissionLevel) {
                    MissionState.addStructure(pos.targetX, pos.targetY, elementName);
                }
                
                if (window.showGameMessage) showGameMessage('Built ' + elementName, 'success');
                
                await render();
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(1)); });
            }
        },

        plant: {
            args: ['cropName'],
            defaults: { cropName: 'wheat' },
            execute: async function(cropName) {
                cropName = String(cropName || 'wheat').replace(/^["']|["']$/g, '');
                
                var px = Math.floor(gameState.playerPos.x);
                var py = Math.floor(gameState.playerPos.y);
                
                if (!gameState.farmPlots) gameState.farmPlots = [];
                
                var existingPlot = gameState.farmPlots.find(function(p) { return p.x === px && p.y === py; });
                if (existingPlot) {
                    if (window.showGameMessage) showGameMessage('Already planted here!', 'error');
                    await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                    return;
                }
                
                var plot = {
                    x: px,
                    y: py,
                    crop: cropName,
                    stage: 'dirt',
                    id: 'farm_' + px + '_' + py + '_' + Date.now()
                };
                gameState.farmPlots.push(plot);
                
                if (window.showGameMessage) showGameMessage('Planted ' + cropName + '!', 'success');
                await render();
                
                plot.timerId = setTimeout(function() {
                    if (plot.cancelled) return;
                    if (plot.stage === 'dirt' && gameState.farmPlots && gameState.farmPlots.includes(plot)) {
                        plot.stage = 'sprout';
                        plot.timerId = null;
                        if (window.showGameMessage) showGameMessage('Sprout appeared!', 'info');
                        render();
                    }
                }, 30000);
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        },

        harvest: {
            execute: async function() {
                var px = Math.floor(gameState.playerPos.x);
                var py = Math.floor(gameState.playerPos.y);
                
                if (!gameState.farmPlots) {
                    if (window.showGameMessage) showGameMessage('Nothing to harvest here', 'error');
                    await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                    return;
                }
                
                var plotIndex = gameState.farmPlots.findIndex(function(p) { return p.x === px && p.y === py; });
                if (plotIndex === -1) {
                    if (window.showGameMessage) showGameMessage('Nothing to harvest here', 'error');
                    await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                    return;
                }
                
                var plot = gameState.farmPlots[plotIndex];
                if (plot.stage !== 'grown') {
                    if (window.showGameMessage) showGameMessage('Not ready to harvest yet!', 'error');
                    await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
                    return;
                }
                
                var cropName = plot.crop;
                
                if (window.MissionState && MissionState.isMissionLevel) {
                    MissionState.addToInventory(cropName, 1);
                    gameState.inventory = MissionState.getInventory();
                } else {
                    if (!gameState.inventory) gameState.inventory = {};
                    gameState.inventory[cropName] = (gameState.inventory[cropName] || 0) + 1;
                }
                
                gameState.farmPlots.splice(plotIndex, 1);
                
                playCollectSound();
                animateCollectSparkle(px, py);
                updateInventoryDisplay();
                if (window.showGameMessage) showGameMessage('Harvested ' + cropName + '!', 'success');
                await render();
                
                await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
            }
        }
    };

    // ========== EXPOSE COMMAND EXECUTORS AS GLOBALS ==========
    
    for (var cmdName in GameCommands) {
        (function(name, cmd) {
            var targetCmd = cmd;
            if (cmd.aliasOf) {
                targetCmd = GameCommands[cmd.aliasOf];
            }
            window['gameCommand_' + name] = function() {
                return targetCmd.execute.apply(null, arguments);
            };
        })(cmdName, GameCommands[cmdName]);
    }
    
    // ========== BACKPACK COMMANDS ==========
    
    window.gameCommand_backpack_append = async function(itemType) {
        var guardResult = ProximityGuard.require({
            mode: 'self',
            sections: ['collectibles'],
            errorTemplate: ProximityGuard.Messages.NOTHING_HERE
        });
        
        var element = guardResult.element;
        
        if (window.MissionState && MissionState.isBackpackFull()) {
            if (window.showGameMessage) showGameMessage('Backpack is full!', 'error');
            throw new Error('Backpack is full! Remove an item first.');
        }
        
        var result = MissionState.addToBackpack(element.type);
        if (result.success) {
            ElementInteractionManager.elementStates[element.id] = { removed: true };
            
            if (MissionState.isMissionLevel) {
                MissionState.markItemCollected(element.x, element.y, element.type);
            }
            
            if (!gameState.backpack) gameState.backpack = [];
            gameState.backpack = MissionState.getBackpack();
            
            playCollectSound();
            animateCollectSparkle(element.x, element.y);
            updateBackpackDisplay();
            await render();
            if (window.showGameMessage) showGameMessage(result.message, 'success');
        }
        
        await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
        return result;
    };
    
    window.gameCommand_backpack_remove = async function(itemType) {
        if (!itemType) {
            if (window.showGameMessage) showGameMessage('No item specified', 'error');
            return { success: false, message: 'No item specified' };
        }
        
        if (!window.MissionState) {
            return { success: false };
        }
        
        var result = MissionState.removeFromBackpack(itemType);
        if (result.success) {
            gameState.backpack = MissionState.getBackpack();
            updateBackpackDisplay();
            await render();
            if (window.showGameMessage) showGameMessage(result.message, 'success');
        } else {
            if (window.showGameMessage) showGameMessage(result.message, 'error');
        }
        
        await new Promise(function(r) { setTimeout(r, getAnimationDuration(0.5)); });
        return result;
    };

    // ========== INVENTORY DICTIONARY ACCESS ==========
    
    window.gameCommand_inventory_get = function(key) {
        if (window.MissionState && MissionState.isMissionLevel) {
            return MissionState.getInventoryCount(key);
        }
        if (!gameState.inventory) {
            gameState.inventory = {};
        }
        var value = gameState.inventory[key];
        return (value !== undefined) ? value : 0;
    };
    
    window.gameCommand_inventory_set = async function(key, value) {
        value = parseInt(value) || 0;
        value = Math.max(0, value);
        
        var currentValue = 0;
        if (window.MissionState && MissionState.isMissionLevel) {
            currentValue = MissionState.getInventoryCount(key);
        } else if (gameState.inventory) {
            currentValue = gameState.inventory[key] || 0;
        }
        
        var diff = value - currentValue;
        
        if (diff > 0) {
            var guardResult = ProximityGuard.check({
                mode: 'self',
                sections: ['collectibles'],
                typeMatch: key
            });
            
            if (!guardResult.success) {
                var message = guardResult.message || 'Nothing to collect here! Move to an item first.';
                if (window.showGameMessage) showGameMessage(message, 'error');
                return currentValue;
            }
            
            var element = guardResult.element;
            
            var consumeResult = ProximityGuard.consume(element);
            if (!consumeResult.success) {
                if (window.showGameMessage) showGameMessage('Failed to collect item', 'error');
                return currentValue;
            }
            
            if (window.showGameMessage) showGameMessage('Collected ' + key, 'success');
            
            if (window.MissionState && MissionState.isMissionLevel) {
                gameState.inventory = MissionState.getInventory();
            }
            
            playCollectSound();
            animateCollectSparkle(element.x, element.y);
            updateInventoryDisplay();
            await render();
            
            var newValue = gameState.inventory[key] || 0;
            return newValue;
        } else if (diff < 0) {
            if (window.MissionState && MissionState.isMissionLevel) {
                var amountToRemove = Math.min(Math.abs(diff), currentValue);
                if (amountToRemove > 0) {
                    MissionState.removeFromInventory(key, amountToRemove);
                }
                gameState.inventory = MissionState.getInventory();
            } else {
                if (!gameState.inventory) {
                    gameState.inventory = {};
                }
                if (value <= 0) {
                    delete gameState.inventory[key];
                } else {
                    gameState.inventory[key] = value;
                }
            }
            
            updateInventoryDisplay();
            await render();
        }
        
        return value;
    };

    // ========== COMMAND COUNTER ==========
    
    var globalCommandCounter = 0;

    window.updateSkulptCommandCounter = function(count) {
        globalCommandCounter = count;
    };

    window.getCommandCount = function() {
        return globalCommandCounter;
    };

    window.resetCommandCounter = function() {
        globalCommandCounter = 0;
    };

    // ========== GAME CONTROL FUNCTIONS ==========
    
    window.runCode = async function() {
        if (window.camera) {
            window.camera.isManualPan = false;
        }
        
        if (window.SkulptRuntime) {
            await window.SkulptRuntime.runCode();
        } else {
            console.error('Skulpt runtime not loaded');
        }
    };

    window.resetGame = async function() {
        if (window.ConfirmDialog) {
            var confirmed = await ConfirmDialog.show({
                title: 'Reset Level',
                message: 'Your code and level progress will be cleared.',
                okText: 'Reset',
                cancelText: 'Cancel'
            });
            if (!confirmed) return;
        }
        
        if (window.ResetManager) {
            ResetManager.fullReset(gameState);
        } else {
            console.error('[resetGame] ResetManager not available');
        }
        
        var starterCode = '';
        if (window.courseData && window.courseData.levels && typeof currentLevel !== 'undefined') {
            starterCode = window.courseData.levels[currentLevel].starterCode || '';
        }
        
        if (window.EditorManager) {
            EditorManager.updateCode(starterCode);
        }
        
        if (window.BlocklyModeSwitcher && window.BlocklyModeSwitcher.isBlockMode()) {
            if (window.BlocklyIntegration) {
                window.BlocklyIntegration.convertFromText(starterCode);
            }
        }
    };

    // ========== EXPORTS ==========
    
    window.GameCommands = GameCommands;

    console.log('[Game Commands] Loaded successfully');
})();
