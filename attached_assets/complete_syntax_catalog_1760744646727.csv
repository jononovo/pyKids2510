Chapter_and_Level,Syntax,Map_Behavior,Game_Example
"Chapter 1, Level 1",player.move_forward(),Player character moves one tile forward in the current facing direction.,"The game world is a 2D grid map. Player starts at a position facing the exit. When student writes `player.move_forward()`, the player sprite visually moves one tile forward. The game state updates the player's position. Student must call this command multiple times to reach the exit. If player tries to move into a wall or obstacle, the game displays an error and the position does not change. Successful completion triggers win animation and level complete message."
"Chapter 1, Level 2",player.turn_left() and player.turn_right(),"Player character rotates 90 degrees left or right, changing facing direction.","Level has a path that requires turning. Player starts facing one direction, must turn to navigate corners. When `player.turn_left()` executes, the player sprite rotates 90 degrees counterclockwise (e.g., from facing East to facing North). No position change, only facing direction updates. Student learns that movement and rotation are separate actions. Multiple turns can be combined with move_forward() to navigate complex paths to the exit."
"Chapter 1, Level 2",player.move_forward(n) - Movement with Arguments,Player character moves forward N tiles in the current facing direction.,"Student needs to move forward 3 tiles. Instead of:
```python
player.move_forward()
player.move_forward()
player.move_forward()
```
They can write:
```python
player.move_forward(3)
```
The game executes 3 forward movements in sequence. If obstacle encountered during multi-tile move, movement stops at the obstacle and error displays. This teaches function parameters and code efficiency."
"Chapter 1, Level 4",player.push(),"Player pushes moveable objects (rocks, boulders) one tile in facing direction.","Level has rocks blocking the path. Game maintains object positions and pushability state. Player must face a rock and call `player.push()`. When executed, game checks if pushable object is in front. If yes and space beyond is empty, object moves one tile forward. Visual animation shows rock sliding. Player position stays same. Now path is clear for movement. If nothing in front or object blocked, error message displays. This teaches environmental manipulation to solve puzzles."
"Chapter 1, Level 5",player.speak(),Displays text message on screen in a speech bubble or text panel; does not affect player position.,"Student writes:
```python
player.speak(""Hello World"")
```
When executed, a speech bubble appears above the player character displaying ""Hello World"". The game interface shows this message in an output panel. Game state includes message history. This teaches string literals and output without using standard print(). It's more engaging for kids - the character ""speaks"" rather than abstract console output. Can be used for debugging (""I am at position 3"") or storytelling during gameplay."
"Chapter 1, Level 6",player.build(object_name),Player constructs specified objects (like bridges) at target location to solve puzzles.,"Level has a gap (river, pit) that blocks progress. Student must build a bridge to cross. Code:
```python
player.move_forward(2)
player.build(""bridge"")
player.move_forward()
```
When `player.build(""bridge"")` executes, game checks if build location is valid. If yes, creates bridge object at specified position, updates map state to mark it passable, shows animation of bridge appearing. Now the previously impassable gap becomes passable. If invalid location or wrong object name, error displays. This teaches: string arguments to specify actions, environmental modification to enable navigation, and resource/construction mechanics."
"Chapter 1, Level Unknown",Level 7 - Apply What You've Learned,,
"Chapter 2, Level 1",player.water(),Player waters crops or plants at the current position or adjacent tiles.,"Level has dry crops marked with X symbols. Student navigates to each crop location and calls `player.water()`. Game state tracks which crops have been watered: `crops = [{""position"": (2,0), ""watered"": False}, ...]`. When student is adjacent to a crop and calls `player.water()`, the crop sprite changes to green/watered, `crops[i][""watered""] = True`, and success animation plays. If no crop nearby, message shows: ""Nothing to water here."" Level completes when all crops watered. This introduces resource-based gameplay where player must use specific actions on specific objects."
"Chapter 2, Level 2",Comments (#),No direct map effect; used to document and explain code logic.,"Level has solution already written in the code editor. To complete, student must make corrections by commenting unnecessary code and uncommenting relevant code. Add or remove the `#` sign (pound). For example:
```python
# player.turn_left()
player.move_forward()
# player.collect()
player.move_forward()
```
Student must determine which lines should run and which should be commented out. When code executes, commented lines are skipped (shown in gray), active lines execute normally. If student comments a required command, player fails to reach exit, teaching that `#` disables code. If student uncomments wrong command, player hits wall. This teaches: comments control which code runs, useful for testing different solutions and documenting logic."
"Chapter 2, Level 3",player.collect(resource_name),Player collects specific resources by name from the environment.,"Level has a water supply and empty canteen. Student's canteen is empty and needs water to fill up. To collect water from water supply:
```python
player.move_forward(2)  # Navigate to water source
player.collect(""water"")  # Fill canteen
```
The string ""water"" must be written exactly as shown. Game state tracks `inventory = {""water"": 0}` and water source location. When student faces water source and calls `player.collect(""water"")`, water amount increments: `inventory[""water""] += 1`, canteen icon fills up, collection sound plays. Student then uses water() on crops. If wrong resource name or spelling: error ""Cannot collect 'watr' - resource not found."" This teaches: string arguments specify what to collect, spelling and quotes matter, functions can work together (collect water, then water crops)."
"Chapter 2, Level 4",player.open() and player.close(),"Player opens or closes doors, chests, gates - changing map accessibility.","Level has doors marked with X symbols - one to open, four to close. Game state tracks door states: `doors = [{""position"": (2,0), ""open"": False}, ...]`. Student must navigate, face stable door, and:
```python
player.move_forward()
player.open()  # Opens the door, now passable
player.move_forward()  # Can walk through
```
When `player.open()` executes while facing closed door, door sprite changes to open state, tile becomes passable, door state updates: `doors[i][""open""] = True`. After going through, student faces other doors:
```python
player.turn_left()
player.close()  # Closes the door
```
Closing makes tile impassable again. This teaches: functions can modify environment state, changing which areas are accessible, and state changes persist (door stays open/closed until changed)."
"Chapter 2, Level 5",Number Variables,"Store item counts, resource quantities for inventory management.","Level requires collecting planks and bricks and storing totals in variables. Game shows item count in corner as student collects. Student writes:
```python
# Collect all planks (let's say there are 5)
player.move_forward()
player.collect()  # Collects plank
# ... repeat navigation and collection
planks = 5  # Store count in variable

# Collect all bricks (let's say there are 3)
player.move_forward(2)
player.collect()  # Collects brick
# ... repeat
bricks = 3  # Store count in variable
```
Game state maintains `variables = {""planks"": 5, ""bricks"": 3}` shown in debug panel. The level checks that variables are created with correct counts. If student tries to proceed without creating variables, message shows: ""Store your counts in variables named 'planks' and 'bricks'."" This teaches: variables store numbers representing game quantities, variable names should be meaningful, numbers on right side of = are stored in name on left side."
"Chapter 2, Level 6",player.place(variable),Player places objects from inventory into containers or locations.,"Level requires collecting wheat, storing in variable, then placing in chest. Student writes:
```python
# Collect wheat (count shown in UI - let's say 12)
player.move_forward()
player.collect()  # Wheat collected
# ... navigate and collect all wheat

wheat = 12  # Store total in variable

# Navigate to chest
player.move_forward(3)
player.turn_right()
player.move_forward(2)

# Place wheat in chest
player.place(wheat)  # Uses variable value

player.close()  # Close chest to complete
```
When `player.place(wheat)` executes, game takes value from `wheat` variable (12) and places that amount in chest at current location. Chest UI shows ""12 wheat stored"". Inventory decreases by that amount. If student tries `player.place(""wheat"")` with string instead of variable, error: ""place() expects a number variable, not a string."" Level completes when correct amount placed and chest closed. This teaches: variables hold values that functions can use, pass variable name (not value) to function, functions can read variable contents."
"Chapter 2, Level 7",String Variables,"Store object names, item types for collection and placement.","Level has three vegetables to collect and store in labeled chests. Student must create string variables with exact names:
```python
# Collect and store in variables
player.move_forward()
player.collect()
bag1 = ""Pumpkin""  # String variable with exact spelling

player.move_forward(2)
player.collect()
bag2 = ""Eggplant""

player.move_forward(2)
player.collect()
bag3 = ""Tomato""

# Navigate to chests and place items
player.move_forward(3)
player.open()  # Open chest
player.place(bag1)  # Places ""Pumpkin""
player.close()

player.move_forward()
player.open()
player.place(bag2)  # Places ""Eggplant""
player.close()

player.move_forward()
player.open()
player.place(bag3)  # Places ""Tomato""
player.close()
```
Game state tracks string variables: `variables = {""bag1"": ""Pumpkin"", ""bag2"": ""Eggplant"", ""bag3"": ""Tomato""}`. When `player.place(bag1)` executes, game reads string value from bag1 and places that item type in chest. Chest label updates to show ""Contains: Pumpkin"". If student misspells: `bag1 = ""Pumkin""`, game doesn't recognize item, error shows. Level completes when all three items correctly collected, stored in string variables, and placed in appropriate chests. This teaches: strings store text in quotes, variable names (bag1) vs string values (""Pumpkin""), strings must match exactly (spelling matters), string variables work with functions like number variables."
"Chapter 3, Level 1",Addition with Variables (+),"Calculate totals of multiple resource counts, combine quantities.","Level requires counting animals in pens and adding amounts together. Game has animal pens: cows in one pen, goats in another, pigs in third. Student must count and create variables:
```python
# Count animals in each pen (student counts visually)
cows = 5      # 5 cows in pen
goats = 3     # 3 goats in pen  
pigs = 4      # 4 pigs in pen

# Walk to X marks and announce counts
player.move_forward(2)
player.speak(cows)      # Announces ""5""

player.move_forward(2)
player.speak(goats)     # Announces ""3""

player.move_forward(2)
player.speak(pigs)      # Announces ""4""

# Final X mark - add all together
player.move_forward(2)
player.speak(cows + goats + pigs)  # Announces ""12""
```
Game state tracks variables: `{""cows"": 5, ""goats"": 3, ""pigs"": 4}`. When `player.speak(cows + goats + pigs)` executes, game evaluates: 5 + 3 + 4 = 12, then displays ""12"" on screen. Level checks that student correctly counts animals and uses `+` to sum variables. If student hardcodes numbers instead of variables, hint shows: ""Use the variables you created!"" This teaches: adding variables combines their values, `+` performs arithmetic with numbers, multiple values can be added in one expression."
"Chapter 3, Level 2",Subtraction Operator (-),"Remove quantities, calculate remaining items after deduction.","Level focuses on egg collection and quality control. Student collects eggs of different colors and tracks bad eggs:
```python
# Collect eggs (counts from collection)
white_eggs = 10
dark_eggs = 8
red_eggs = 6

# First task: subtract bad eggs (4 total)
player.move_forward(3)
player.speak(white_eggs + dark_eggs + red_eggs - 4)  # 24 - 4 = 20 good eggs

# Second task: calculate nutrition (red eggs worth 2x)
player.move_forward(2)
player.speak(white_eggs - 4 + dark_eggs + red_eggs * 2)  # Complex calculation
```
Game displays egg collection UI showing counts. When `player.speak(white_eggs + dark_eggs + red_eggs - 4)` executes, game calculates: 10 + 8 + 6 - 4 = 20, displays result. The subtraction removes bad eggs from total. Second calculation shows combined operators: subtraction, addition, multiplication. If student forgets to subtract bad eggs, level doesn't complete, teaching that `-` is essential for accurate counting. This teaches: subtraction reduces values, operators can combine in expressions, order of operations matters."
"Chapter 3, Level 2",Multiplication Operator (*),"Calculate scaled values, repeat actions, or multiply resource worth.","In Level 2's egg counting, red eggs are twice as nutritious. Student uses `*` for calculation:
```python
red_eggs = 6
nutritional_value = red_eggs * 2  # 6 * 2 = 12
player.speak(nutritional_value)
```
Level 3 introduces string multiplication for sound effects:
```python
# Call chickens by chirping 10 times
player.speak(""Chirp"" * 10)  # Displays ""ChirpChirpChirpChirpChirpChirpChirpChirpChirpChirp""
```
When `""Chirp"" * 10` executes, game repeats string 10 times, creates long chirping sound effect. Visual shows ""Chirp"" appearing 10 times rapidly. If student tries `""Chirp"" * ""Chirp""`, error: ""can't multiply sequence by non-int,"" teaching that string multiplication requires integer. This teaches: `*` multiplies numbers for math, repeats strings for patterns, multiplication useful for scaling and repetition."
"Chapter 3, Level 3",String Formatting with %d,Create dynamic messages that include variable values.,"Level requires counting chickens in coups and announcing counts using formatted strings:
```python
# Count chickens (student counts visually)
left_coup = 7
right_coup = 5

# Announce using string formatting
player.move_forward(2)
player.speak(""Right Coup has %d Chickens"" % (right_coup))  # Shows ""Right Coup has 5 Chickens""

player.move_forward(2)
player.speak(""Left Coup has %d Chickens"" % (left_coup))   # Shows ""Left Coup has 7 Chickens""
```
When `""Right Coup has %d Chickens"" % (right_coup)` executes, game:
1. Finds `%d` placeholder in string
2. Replaces it with value from variable `right_coup` (5)
3. Displays final string: ""Right Coup has 5 Chickens""

Game highlights `%d` in yellow when code runs, shows arrow pointing from variable to placeholder, then final string appears. If student forgets `%` operator: `""Right Coup has %d Chickens"" (right_coup)`, shows syntax error. If wrong placeholder `%s` used with number, displays incorrectly. This teaches: `%d` marks where number goes in string, `% (variable)` provides the number, strings and numbers combine for dynamic messages."
"Chapter 3, Level 4",Constants (Uppercase Variables),Store fixed game values like total resources available.,"Level provides pre-defined constant `egg_basket` containing total eggs:
```python
# Constant provided by game (student sees this)
egg_basket = 20  # CONSTANT - total eggs available

# Student creates variables to split eggs
bag1 = egg_basket / 2   # 10 eggs
bag2 = egg_basket / 2   # 10 eggs

# Place in containers
player.move_forward(2)
player.place(bag1)

player.move_forward()
player.place(bag2)

# Announce total
player.move_forward(2)
player.speak(""Total eggs: %d"" % (egg_basket))  # Shows ""Total eggs: 20""
```
Game shows constant in special color (blue) to distinguish from regular variables. Tooltip explains: ""egg_basket is a CONSTANT - value doesn't change during game."" When student modifies `egg_basket = 30`, warning shows: ""Constants should not be changed!"" but code still runs. This teaches: constants store fixed values, uppercase names indicate don't change, constants useful for game-wide values referenced multiple places."
"Chapter 3, Level 4",Division Operator (/),"Split resources evenly, calculate portions, divide quantities.","Level requires dividing eggs from constant into two equal bags:
```python
egg_basket = 20  # Total eggs (constant)

# Divide equally
bag1 = egg_basket / 2   # 20 / 2 = 10
bag2 = egg_basket / 2   # 20 / 2 = 10

player.speak(bag1)  # Shows ""10"" (or ""10.0"")
```
When `egg_basket / 2` executes, game shows division animation: 20 eggs splitting into two groups of 10. Result shows as 10 (game may show float 10.0). If student tries division creating uneven split: `egg_basket / 3`, result is 6.666... Game shows decimal number, teaches that division can create fractions. If student tries `egg_basket / 0`, error: ""ZeroDivisionError: division by zero,"" with helpful message: ""Cannot divide by zero!"" This teaches: `/` divides numbers, division creates equal portions, dividing by zero is error, results can be decimals."
"Chapter 4, Level 1",while Loop,Collect eggs in barn using only 6 lines of code by repeating movement with while loop.,"Level 1: Collect all eggs in barn with code limit of 6 lines. Set up variable count and use while loop:

```python
count = 0
while count < [number_of_cycles]:
    player.move_forward()
    player.collect()
    count = count + 1
```

The variable `count` is set to `0` and determines how many cycles the loop runs. The while loop uses `count` to test if loop cycle should execute. Indented movement code repeats as long as while condition returns `True`.

The variable `count` increases by `1` each cycle to meet the condition for loop finalization.

**Key Teaching Point**: Must indent code after loop code for it to be part of loop, otherwise code won't loop.

**Caution**: While loops can fall into infinite loop (code repeated forever causing program to crash). Always set up cap or stopping point. Use `count` variable to cap number of cycles to prevent infinite loop.

**Code Constraint**: Complete with only 6 lines - forces efficient loop usage instead of repeated individual commands."
"Chapter 4, Level 2",for Loop with range(),Navigate hedge maze by repeating movement pattern to reach exit.,"Level 2: Use for loop to reach exit. The for loop repeats same code a set number of times:

```python
for x in range(4):
    player.move_forward()
    player.turn_right()
    player.move_forward()
    player.turn_left()
```

The `range()` determines how many times looping code runs (in this example it is four).

Remember must indent code after loop code for it to be part of loop, otherwise code won't loop.

Loop movements across hedge maze and reach exit to complete level.

**Key Teaching Point**: For loop is simpler when you know exact number of iterations. No counter variable needed - range() handles it automatically.

**Comparison to while loop**:
- `while`: Good when condition-based (until something happens)
- `for`: Good when count-based (do this N times)"
"Chapter 4, Level 3",Integrating Functions in Loops,"Traverse field, water crops, and reach exit using either for or while loop with functions.","Level 3: Use for loop or while loop to traverse field, water crops, and reach exit.

**For while loop approach**:
```python
count = 0
while count < 4:
    player.move_forward()
    player.water()  # Function called inside loop
    count = count + 1
```

Variable `count` set to `0`, used to determine loop cycles. While loop uses `count` to test execution. Tabbed code repeats as long as while condition returns true. Count increased by `1` to meet finalization condition.

**For loop approach**:
```python
for x in range(4):
    player.move_forward()
    player.water()  # Function called inside loop
```

The for loop repeats same code set number of times. The `range()` determines iterations (in this case four).

Must tab code after loop for it to be part of loop, otherwise code won't loop.

Loop movements across field, water crops, reach exit to complete level.

**Caution**: While loops can fall into infinite loop. Always set up cap/stopping point using count variable.

**Key Teaching Point**: Both loop types can call functions. Students choose appropriate loop type based on problem structure. This level introduces decision-making: ""Which loop is better for this task?"""
"Chapter 4, Level 4",Dynamic Loop Variables,Navigate maze and collect grains using dynamic movement based on loop variable - complete in under 4 lines.,"Level 4: Make full use of for loop's variable to navigate maze and collect all grains in under 4 lines of code.

The variable (usually named `x` but can be named anything) starts at `0` and increments by `1` each loop cycle:

```python
for x in range([number]):
    player.move_forward(x + 1)
    player.collect()
```

By adding variable to function `move_forward()`, you increase number of steps each cycle. By adding `+1`, movement code starts at `1` instead of `0`.

**Example progression**:
- Cycle 0: `x = 0`, so `move_forward(0 + 1)` = move 1 step
- Cycle 1: `x = 1`, so `move_forward(1 + 1)` = move 2 steps
- Cycle 2: `x = 2`, so `move_forward(2 + 1)` = move 3 steps
- And so on...

By executing loop with correct cycle count, collect all grains and complete level.

**Key Teaching Point**: Loop variables aren't just counters - they're dynamic values that can control behavior. This creates patterns: 1, 2, 3, 4... steps. Demonstrates how loops enable code that would be impossible to write manually (imagine writing 100 increasing movements!).

**Optimization Focus**: 4-line limit teaches that loops dramatically reduce code. Without loops, this level would require dozens of lines."
"Chapter 5, Level 1",List Creation with Numbers [],"Collect eggs and store in list, then place list in container using place() function.","Level 1: Walk through barn and collect all eggs. Three classes: blue eggs, red eggs, green eggs.

After collecting, place them inside list:

```python
eggs = [5, 3, 7]  # blue, red, green egg counts
```

Once list is set up, head for X mark, face container, store list using `place()` function:

```python
player.place(eggs)
```

**Key Teaching Point**: Lists group related values together. Square brackets `[]` define list, commas separate items. Lists can be passed to functions as single unit."
"Chapter 5, Level 2",List Concatenation (Adding Lists),"Grab items, create separate lists, add lists together, use combine() function to mix items.","Level 2: Grab all items, put in lists, mix together. Grab milk and cream items:

```python
dairy = [""milk"", ""cream""]
```

After that list complete, grab vegetables and add to list:

```python
vegetables = [""lettuce"", ""tomato"", ""cucumber""]
```

Once all items picked up and lists made, add lists together:

```python
ingredients = dairy + vegetables
```

Afterwards head for X mark and use `combine()` function to mix items into large glass jar:

```python
player.combine(ingredients)
```

**Key Teaching Point**: Lists can be added with `+` operator. Result is new list containing all elements from both lists in order. Combined list works with functions just like single list."
"Chapter 5, Level 3",String Lists,"Place pig food in trays, then call piglets by name using list with for loop and speak() function.","Level 3: Walk over pig food to grab it. Walk to two X marks and place food in trays using `place()`:

```python
player.place(""pig_food"")
player.place(""pig_food"")
```

After placing food, walk to lighter X mark and call piglets by putting names in list and using for loop with `speak()` function:

```python
piglets = [""Peggle"", ""Peter"", ""Piper"", ""Pedro""]

for x in piglets:
    player.speak(""Come here %s"" % x)
```

By adding `x` value, for loop runs through each entry in list until it reads all names.

**Output**:
```
Come here Peggle
Come here Peter
Come here Piper
Come here Pedro
```

**Key Teaching Point**: Lists can hold strings (names, words) not just numbers. `%s` in string acts as placeholder, replaced by loop variable. For loops iterate through list values directly, not indices."
"Chapter 5, Level 5",List Index Access [index],"Collect egg basket, check contents with while loop, distribute eggs to containers using list indices.","Level 5: Collect and check egg basket contents before distributing. Grab basket, walk to light X mark to check eggs. Use while loop through contents, displayed via two list constants:

```python
eggs = [""blue"", ""red"", ""green"", ""white""]  # types
basket = [4, 6, 3, 5]  # quantities
```

Eggs stored in compartments `0` through `3` in this order:
- Position 0: blue eggs (4)
- Position 1: red eggs (6)
- Position 2: green eggs (3)
- Position 3: white eggs (5)

Walk to each of four dark X marks and store eggs in containers. Containers have signs above detailing egg color. Use `place()` function with list indices:

```python
player.place(""blue"", basket[0])    # 4 blue eggs
player.place(""red"", basket[1])     # 6 red eggs
player.place(""green"", basket[2])   # 3 green eggs
player.place(""white"", basket[3])   # 5 white eggs
```

Access specific value with `listname[position]` syntax.

**Key Teaching Point**: Lists are indexed starting at 0, not 1. `basket[0]` is first item, `basket[1]` is second, etc. Index access lets you isolate specific values from list."
"Chapter 5, Level 6",List Assignment list[index] = value,"Determine egg counts from incubators, assign values into list, read through data with for loop.","Level 6: Determine how many colored eggs laid by chickens. Set up lists to store values:

```python
eggs = [""red"", ""white"", ""blue""]
chickens = [""Henrietta"", ""Gertrude"", ""Beatrice""]
```

Set up shortcut variables for colored egg lists:

```python
red = 0
white = 0
blue = 0
```

Walk to dark X marks, use `speak()` to determine egg counts from each incubator. Use constants `red_incubator`, `white_incubator`, `blue_incubator` to check values, then insert into list:

```python
player.speak(red_incubator)    # Shows number, e.g., 5
colored_eggs = [0, 0, 0]       # Initialize empty list
colored_eggs[0] = red_incubator   # Assign red egg count
colored_eggs[1] = white_incubator # Assign white egg count
colored_eggs[2] = blue_incubator  # Assign blue egg count
```

Once all values assigned, walk to light X mark and use for loop to read through all data:

```python
for count in colored_eggs:
    player.speak(count)
```

**Key Teaching Point**: List values can be changed after creation. Use `list[index] = value` to assign. This lets you build lists dynamically based on game state or calculations."
"Chapter 5, Level 6",List append() Method,Add berry counts to list as you collect them around courtyard.,"Level 6 (from Chapter 6, referenced here): Grab berries from courtyard, store in list:

```python
berries = []  # Start with empty list

# As you collect each type
berries.append(3)   # 3 red berries
berries.append(5)   # 5 blue berries  
berries.append(4)   # 4 black berries

# Result: berries = [3, 5, 4]
```

**Key Teaching Point**: `append()` grows list dynamically. Start with empty list `[]`, add items as needed. Different from assigning to index (which requires list already exists with that index)."
"Chapter 6, Level 1",if Statement with Comparison Operators,"Collect eggs, store in list, compare them using if statements at X marks.","Level 1: Walk through field and collect all eggs, store in list, compare by setting conditions. Level holds constant named `eggs` representing general value for eggs in room.

Collect all eggs, place inside list:

```python
collected_eggs = [12, 8, 12]  # Three types collected
```

After placing eggs in list, compare them in if statement by testing against each other. Head for three X marks and compare items on list:

```python
if collected_eggs[0] == collected_eggs[2]:
    player.speak(""First and third are equal"")

if collected_eggs[1] != collected_eggs[0]:
    player.speak(""Second is different from first"")
```

Remember `==` checks if two items are same, `!=` checks if two items are not same.

**Key Teaching Point**: If statements enable conditional execution. Code inside if only runs when condition is True. Comparison operators (`==`, `!=`) return True/False."
"Chapter 6, Level 2",Complex if Statements with Logical Operators,"Gather items in list, use if statements with multiple checks to combine items.","Level 2: Gather all items in field and put in list named stash:

```python
stash = [""flour"", ""sugar"", ""eggs"", ""butter""]
```

After list complete, head over to X marks and combine items. Using if statement, single out items and check using `and` and `or` operators, check if inside list using `in` operator. Inside statement use `combine()` function:

```python
if ""flour"" in stash and ""eggs"" in stash:
    player.combine([""flour"", ""eggs""])

if ""sugar"" in stash or ""honey"" in stash:
    player.combine([""sugar""])  # or honey if available
```

**Key Teaching Point**: 
- `and`: Both conditions must be True
- `or`: At least one condition must be True  
- `in`: Checks if item exists in list"
"Chapter 6, Level 3",len() Function with Conditions,"Check if all items collected before combining, using len() with comparison operators.","Level 3: Grab items in field (lettuce, tomatoes), then retrieve remaining items using collect() function with for loop checking if carrots and cucumbers can be collected:

```python
vegetables = []
# Grab lettuce and tomatoes by walking over them

# Check containers for additional items
for item in [""carrots"", ""cucumbers""]:
    player.collect(item)
    vegetables.append(item)
```

Once all items collected, store in list:

```python
vegetables = [""lettuce"", ""tomato"", ""carrots"", ""cucumbers""]
```

Head for light X mark and check if all items in list before combining. Use `len()` operator and `<` or `>` to check if list complete, then use `combine()`:

```python
if len(vegetables) >= 4:
    player.combine(vegetables)
```

**Key Teaching Point**: `len()` returns list length. Useful for validation: ""Do I have enough items?"" Combined with comparison operators for threshold checks."
"Chapter 6, Level 4",break Statement,"Collect weeds in while loop until bag full, use break to end loop when condition met.","Level 4: Gather all weeds in passage and dump them. Use loops with conditions to automate process.

First gather all weeds using while loop. Create variable `bag`, have while loop automatically fill until all weeds picked up. Ten (10) weeds total, use condition inside while loop to check if all ten grabbed, use `break` to end loop:

```python
bag = 0
while True:
    player.move_forward()
    bag = bag + 1
    if bag >= 10:
        break  # Exit loop when 10 weeds collected
```

**Key Teaching Point**: `break` provides emergency exit from loops. Useful when exit condition occurs mid-loop. Prevents unnecessary iterations after goal reached."
"Chapter 6, Level 4",continue Statement,Skip placing weeds when at gap between containers.,"Level 4: After collecting weeds, use for loop to dump weeds in containers using `place()` function at X marks. Gap between two (2) containers, so use `continue` operator to skip code if condition met:

```python
for x in range(3):
    if x == 1:
        continue  # Skip middle position (gap)
    player.place(bag/2)
    player.move_forward()
```

Use if statement to check if loop cycle reached `1` (middle ground between containers), if so skip cycle. Two containers, so split bag variable in half: `player.place(bag/2)`.

**Key Teaching Point**: `continue` skips current iteration, not entire loop like `break`. Useful for ""skip this case, do others"" logic. Different from if/else - cleaner when skipping complex code blocks."
"Chapter 6, Level 5",else Statement,Handle different weed counts in passages - first passage different from rest.,"Level 5: Collect all weeds and dump using no more than twelve (12) lines of code. Use loops with proper conditions to efficiently navigate.

Create for loop with range(3) - three passages. First passage has five (5) weeds, rest have nine (9):

```python
for x in range(3):
    player.move_forward(9)  # Length of passage
    
    if x == 0:
        bag = 5  # First passage
        player.place(bag)
    else:
        bag = 9  # Other passages
        player.place(bag)
    
    player.turn_right()
    player.move_forward(2)
    player.turn_right()
```

Set up condition to check if in first passage. If so, place five (5) weeds. Set up `else` statement with variant code placing nine (9) weeds if condition not met.

**Key Teaching Point**: `else` handles ""all other cases."" Makes code complete: if this, do A, otherwise do B. No condition needed on else - it's the default case."
"Chapter 6, Level 6",elif (else-if) Statement,"Different berry types per loop cycle, check which cycle and act accordingly.","Level 6: Grab all berries to combine into Jam using loop conditions. Create list named berries. Three edges of courtyard lined with berries.

Three types: 3 red berries, 5 blue berries, 4 black berries (purple):

```python
berries = []

for x in range(3):
    # Move to edge
    player.move_forward(5)
    
    if x == 0:
        # Red berries
        count = 3
    elif x == 1:
        # Blue berries
        count = 5
    else:
        # Black berries
        count = 4
    
    berries.append(count)
    
    # Turn for next edge
    player.turn_right()
```

Since each edge has same type berry, set up conditions for each loop cycle. Test which cycle currently at, store number collected in variable, use `append()` to add value to list.

Once done adding all values, use `else` statement to wrap up loop, have player make way to X mark and use `combine()` function to mix berries into jelly.

**Key Teaching Point**: Multiple conditions tested in sequence. First match wins, rest skipped. Structure: if/elif/elif.../else. Cleaner than nested if statements."
"Chapter 6, Level 2",in Operator,Check if specific items in ingredient list before combining.,"Covered in Level 2 and 3. Check if items in list:

```python
if ""carrots"" in vegetables:
    player.speak(""We have carrots"")

if ""onions"" not in vegetables:
    player.speak(""Missing onions"")
```

**Key Teaching Point**: `in` is cleaner than manual search. No need to loop through list checking each item. Works with lists, strings, dictionaries (later). Partner operator: `not in`."
"Chapter 7, Level 1",def Statement (Function Definition),Create custom commands that combine multiple actions (push rocks repeatedly).,"Level 1 teaches creating custom functions to reduce code length. Game objective: reach the end of the level by writing no more than 22 lines of code. Without functions, student would repeat the same `push()` and `move_forward()` commands multiple times. 

Create a custom function named `repeat_push()`:
```python
def repeat_push():
    push()
    move_forward()
```

This consolidates eight lines of code into a reusable function. Move towards the rocks and use `repeat_push()` four times in areas that require it to reach the star and end the level.

Key syntax: `def` keyword, function name, parentheses `()`, colon `:`, indented body. Function creates reusable ""recipe"" stored in memory - defined once, executed multiple times."
"Chapter 7, Level 1",Function Call,Execute custom command sequence with single function call.,"Level 1 emphasizes calling the defined function. After defining `repeat_push()`, the student calls it four times:

```python
repeat_push()
repeat_push()
repeat_push()
repeat_push()
```

Each call executes the entire function body (push and move forward). Game state tracks function calls and shows code reduction from potentially 32 lines (8 commands Ã— 4 repetitions) down to definition + 4 calls."
"Chapter 7, Level 2",Function Parameters,Pass counts or distances to customize function behavior (water different number of crops).,"Level 2 requires watering all crops writing no more than 13 lines of code. Create a custom function with a for loop that can be manipulated using arguments:

```python
def water_crops(count):
    for i in range(count):
        water()
        move_forward()
```

Use this function three times with different values corresponding to the number of X marks in a row:
```python
water_crops(4)  # Waters 4 crops
water_crops(3)  # Waters 3 crops  
water_crops(5)  # Waters 5 crops
```

Same function, different behaviors based on argument. Game shows `count` variable inside function receives value from call. When `water_crops(4)` executes, `count = 4` inside function."
"Chapter 7, Level 3",return Statement,Calculate result (count items in field) and send back to caller.,"Level 3: walk to each X mark and count the number of items in the field using return values. Three items total: `""Red Mandrake""`, `""Blue Mandrake""` and `""Poison Mushroom""`.

Create functions that count items and return values:
```python
def count_red_mandrake():
    # Count logic here
    return red_count

def count_blue_mandrake():
    # Count logic here
    return blue_count

def count_poison_mushroom():
    # Count logic here
    return poison_count
```

On the last X mark, add the numbers using another custom function:
```python
def add_counts(a, b, c):
    total = a + b + c
    return total

total_items = add_counts(count_red_mandrake(), count_blue_mandrake(), count_poison_mushroom())
```

Functions return values that can be used by other functions. Game shows return values flowing from one function to another for calculation."
"Chapter 7, Level 4",Lists in Functions,Use lists to synchronize data (vegetables and their quantities) for processing.,"Level 4: gather all vegetables and take them to the press (X mark) to pickle them using a custom function. Set up custom function `pickle()`:

```python
def pickle(food_list, number_list):
    for i in range(len(food_list)):
        # Pickle food_list[i] with number_list[i] quantity
        player.pickle(food_list[i], number_list[i])
```

This function uses two lists as arguments: one for food names, one for quantities. Gather vegetables, create the lists:

```python
vegetables = [""Cucumbers"", ""Tomatoes"", ""Radishes""]
```

Create variables for counts and put in list:
```python
cucumber_count = 5
tomato_count = 3
radish_count = 7
vegetable_number = [cucumber_count, tomato_count, radish_count]
```

Head to X mark and pickle:
```python
pickle(vegetables, vegetable_number)
```

Function iterates through both lists in parallel, pairing vegetables with their quantities. Game demonstrates list indexing: `food_list[0]` pairs with `number_list[0]`, etc."
"Chapter 7, Level 5",Conditions in Functions,Use string arguments to determine which action sequence to execute (open gates or build bridges).,"Level 5: create custom function to navigate swamp by opening gates and building bridges. Function must have conditions to work for both tasks.

Create `navigate_swamp` function with string argument:
```python
def navigate_swamp(action):
    if action == ""build"":
        # Build bridge logic
        build()
        move_forward()
        build()
        move_forward()
        build()
        move_forward()
    elif action == ""open"":
        # Open gate logic
        open()
        move_forward()
        turn_around()
        close()
```

The `""build""` condition uses `build()` function with movement, repeated 3 times to clear the bridge. The `""open""` condition opens gate, moves across, turns around, and closes it.

Use the function to navigate:
```python
navigate_swamp(""open"")   # Opens and closes gate
navigate_swamp(""build"")  # Builds bridge
navigate_swamp(""open"")   # Opens another gate
```

Same function performs completely different operations based on string argument. Pick up all logs before building bridges. Game shows how single function can encapsulate multiple behaviors selected by conditions."
"Chapter 7, Level 6",Operators in Functions,"Calculate serving sizes using division, check quantities with comparisons.","Level 6: check if you have enough berries to mash for a serving of puree. Create variable for serving size:

```python
serving = total_berries / berry_types  # Calculate serving size
```

Create `mash_berries` function that checks if amount is enough for serving:
```python
def mash_berries(amount):
    if amount >= serving:
        speak(""Enough berries for puree!"")
        # Mash the berries
    elif amount < serving:
        speak(""Not enough berries"")
    else:
        speak(""Exact serving size"")
```

Grab all berries in field and store in variables:
```python
red_berries = 15
blue_berries = 8  
black_berries = 12
```

Walk to X marks and use function with each variable:
```python
mash_berries(red_berries)    # Checks 15 berries
mash_berries(blue_berries)   # Checks 8 berries
mash_berries(black_berries)  # Checks 12 berries
```

Function uses division operator to calculate serving size, comparison operators (`>=`, `<`) to check quantities, and conditions to display different messages. Game demonstrates how operators enable functions to perform calculations and make decisions."
"Chapter 8, Level 1",Dictionary Creation Syntax {key: value},Store collected items with their names as keys and quantities as values.,"Level 1: walk through field and grab all fruit (Apples, Oranges, Pears). Store in dictionary named `bag` with index being fruit name and value being quantity:

```python
bag = {
    ""Apples"": 5,
    ""Oranges"": 3,
    ""Pears"": 7
}
```

Dictionary uses curly braces `{}`, key-value pairs separated by colons `:`, pairs separated by commas. Unlike lists (indexed by numbers 0,1,2...), dictionaries indexed by meaningful keys (fruit names).

Walk to X mark and use speak function to count fruits:
```python
player.speak(f""Apples: {bag['Apples']}"")
player.speak(f""Oranges: {bag['Oranges']}"")  
player.speak(f""Pears: {bag['Pears']}"")
```

Access dictionary values using `dict[key]` syntax. Game shows visual distinction: lists use brackets `[0]`, dictionaries use descriptive keys `[""Apples""]`.

**Key Teaching Point**: Dictionaries organize data with meaningful labels instead of numeric indices. Perfect for inventory systems where item names are more intuitive than numbers."
"Chapter 8, Level 2",Dictionary with plant() Function,"Use plant() function to plant seeds from dictionary, then water crops.","Level 2: constant named `seeds` holds 4 different crop seeds: `""Pumpkin""`, `""Eggplant""`, `""Tomato""`, `""Melon""`. Walk to each X mark and use `plant()` function to plant all seeds in respective areas, then `water()` to water crops:

```python
# seeds constant provided by game
seeds = {
    ""Pumpkin"": 4,
    ""Eggplant"": 3,
    ""Tomato"": 5,
    ""Melon"": 2
}

# At each X mark
player.plant(""Pumpkin"", seeds[""Pumpkin""])
player.water()
```

The `plant()` function takes seed name and quantity from dictionary. Repeat for each seed type at corresponding X marks.

Finally, head to middle light X mark and count all planted seeds:
```python
total_planted = seeds[""Pumpkin""] + seeds[""Eggplant""] + seeds[""Tomato""] + seeds[""Melon""]
player.speak(f""Total seeds planted: {total_planted}"")
```

**Key Teaching Point**: Dictionaries work seamlessly with functions. Access values by name, pass to functions, aggregate totals. More intuitive than remembering which index represents which seed type."
"Chapter 8, Level 3",del Keyword (Dictionary Deletion),"Remove unwanted items from crate dictionaries (Pipes, Screws, Bolts).","Level 3: remove items from dictionary constants `crate1`, `crate2`, `crate3`, `crate4`, `crate5`. Items to remove: `""Pipes""`, `""Screws""`, `""Bolts""`.

Walk to each X mark in front of containers, use `speak()` to find what's inside each crate:
```python
player.speak(crate1)  # Shows: {""Pipes"": 3, ""Nails"": 5, ""Screws"": 2}
```

If undesired items present, use `del` to remove:
```python
if ""Pipes"" in crate1:
    del crate1[""Pipes""]
if ""Screws"" in crate1:
    del crate1[""Screws""]
if ""Bolts"" in crate1:
    del crate1[""Bolts""]
```

Do this for all five crates - inspect contents, remove undesirables:
```python
# Crate 2
player.speak(crate2)
del crate2[""Screws""]
del crate2[""Bolts""]

# Crate 3  
player.speak(crate3)
del crate3[""Pipes""]
# etc.
```

**Key Teaching Point**: `del` syntax permanently removes key-value pairs. Check existence with `in` operator before deleting to avoid errors. Dictionary becomes smaller as items removed."
"Chapter 8, Level 4",Dictionary Value Access in Functions,Use place() function with dictionary values to store crops in containers.,"Level 4: gather all crops on field and place in storeroom. Four crop types: `""corn""`, `""carrot""`, `""wheat""`, `""parsnip""`. Collect crops, store in dictionary with quantities:

```python
crops = {
    ""corn"": 12,
    ""carrot"": 8,
    ""wheat"": 15,
    ""parsnip"": 6
}
```

Walk to each X mark (accompanied by sign outlining crop type) and store in containers using `place()`:
```python
# At corn container
player.place(""corn"", crops[""corn""])  # Places 12 corn

# At carrot container  
player.place(""carrot"", crops[""carrot""])  # Places 8 carrots

# At wheat container
player.place(""wheat"", crops[""wheat""])  # Places 15 wheat

# At parsnip container
player.place(""parsnip"", crops[""parsnip""])  # Places 6 parsnips
```

Place crops in correct containers matching signs. Game validates: crop name must match container label.

**Key Teaching Point**: Dictionary values isolated and used with functions. Single data structure (crops dict) provides both item names and quantities. Signs on map correspond to dictionary keys - visual/data connection."
"Chapter 8, Level 5",Dictionaries in Custom Functions,Custom sow_field function uses dictionary values to plant and water trees.,"Level 5: collect seeds and water to prep for sowing field. First, grab bag holding seeds (dictionary provided):
```python
seeds = {
    ""orange"": 3,
    ""pear"": 4,
    ""apple"": 3,
    ""peach"": 2
}
```

Walk to light X mark, face well, collect water:
```python
player.collect(""water"")
```

Create function `sow_field` with arguments: `tree`, `loops`, `direction`:
```python
def sow_field(tree, loops, direction):
    for i in range(loops):
        player.plant(tree, 1)
        player.water()
        if direction == ""left"":
            player.turn_left()
            player.move_forward()
            player.turn_right()
        elif direction == ""right"":
            player.turn_right()
            player.move_forward()  
            player.turn_left()
```

Arguments:
- `tree`: seed name from dictionary (`""orange""`, `""pear""`, `""apple""`, `""peach""`)
- `loops`: number of times to execute (equals seed quantity from dictionary)
- `direction`: `""left""` or `""right""` for movement

Head to top of map, use custom function to plant and water trees:
```python
sow_field(""orange"", seeds[""orange""], ""right"")  # Plant 3 orange trees, move right
sow_field(""pear"", seeds[""pear""], ""right"")      # Plant 4 pear trees, move right
sow_field(""apple"", seeds[""apple""], ""left"")     # Plant 3 apple trees, move left
sow_field(""peach"", seeds[""peach""], ""left"")     # Plant 2 peach trees, move left
```

Dictionary values determine loop iterations. Function combines planting, watering, and directional movement.

**Key Teaching Point**: Dictionaries + custom functions = dynamic behavior. Dictionary values control function execution (how many iterations). Single function handles all tree types using dictionary keys."
"Chapter 8, Level 6",Dictionary Iteration with for Loop,Iterate materials dictionary to categorize and place items in containers.,"Level 6: several materials scattered across field need picking up, categorizing, and putting away. Collect all materials: `""branches""`, `""boulders""`, `""planks""`. Place in dictionary with quantities:

```python
materials = {
    ""branches"": 8,
    ""boulders"": 5,
    ""planks"": 12
}
```

Walk to light X mark, use `for` loop to iterate dictionary using `speak()`:
```python
for material in materials:
    player.speak(f""{material}: {materials[material]}"")
```

Output shows:
```
branches: 8
boulders: 5
planks: 12
```

Iteration pattern: `for key in dict:` gives keys, access values with `dict[key]`. Alternative with items():
```python
for material, quantity in materials.items():
    player.speak(f""{material}: {quantity}"")
```

Walk to three dark X marks, use `place()` to store each material:
```python
# Left container - branches
player.place(""branches"", materials[""branches""])

# Middle container - boulders  
player.place(""boulders"", materials[""boulders""])

# Right container - planks
player.place(""planks"", materials[""planks""])
```

Put everything in correct position to complete level.

**Key Teaching Point**: Dictionary iteration differs from lists. Lists iterate values directly, dictionaries iterate keys (then access values). Use `dict.items()` for simultaneous key-value access. For loop + dictionary = automatic categorization."
"Chapter 9, Level 1",class Keyword (Class Definition),Create class for grain stacks that can be built multiple times.,"Level 1: create grain stacks by using classes. Define a class as blueprint:

```python
class GrainStack:
    pass  # Class definition
```

Class defines the type of object. Think of it as a template or cookie cutter. Once class is set up, create objects (individual instances):

```python
stack1 = GrainStack()
stack2 = GrainStack()
stack3 = GrainStack()
```

Each variable (`stack1`, `stack2`, `stack3`) is separate object created from same class. Grab all grains in field, walk to three X marks. Use `build()` function to construct objects:

```python
player.build(stack1)
player.build(stack2)
player.build(stack3)
```

Each `build()` call creates physical grain stack from class object.

**Key Teaching Point**: Classes are blueprints, objects are instances. One class definition â†’ many object instances. Game visualizes: class as schematic diagram, objects as actual constructions. Syntax: `class ClassName:` with capital first letter by convention."
"Chapter 9, Level 2",__init__ Method (Constructor),Set up road properties (material type) when creating road objects.,"Level 2: complete roads using materials from field. Classes create objects with `__init__` method:

```python
class Road:
    def __init__(self, material):
        self.material = material
```

The `__init__` method runs automatically when object created. `self` refers to the object itself, `material` is parameter passed when creating object.

Grab all planks and stones in field, set up class, then create objects:

```python
wooden_road = Road(""wood"")
stone_road = Road(""stone"")
```

When `Road(""wood"")` executes:
1. New Road object created
2. `__init__` runs automatically
3. `self.material` set to `""wood""`
4. Object returned and stored in `wooden_road`

Walk to X marks and build roads:
```python
player.build(wooden_road)  # Builds wooden road
player.build(stone_road)   # Builds stone road
```

Each object has different `material` attribute, so different roads built.

**Key Teaching Point**: `__init__` is constructor - special method for initialization. Syntax: `def __init__(self, params):` with double underscores. `self` is first parameter, refers to object being created. Parameters after `self` customize each object."
"Chapter 9, Level 3",Class Attributes/Properties,"Store house properties (color, size) for building different chicken houses.","Level 3: collect planks and build 4 chicken houses with different properties. Create class with two variables:

```python
class ChickenHouse:
    def __init__(self, color, size):
        self.color = color
        self.size = size
```

Each object has two properties: `color` and `size`. Grab all planks, walk to X marks, create 4 different objects:

```python
big_green_house = ChickenHouse(""green"", ""big"")
small_blue_house = ChickenHouse(""blue"", ""small"")
big_orange_house = ChickenHouse(""orange"", ""big"")
small_red_house = ChickenHouse(""red"", ""small"")
```

Each object has different property values:
- `big_green_house.color` = `""green""`, `big_green_house.size` = `""big""`
- `small_blue_house.color` = `""blue""`, `small_blue_house.size` = `""small""`
- etc.

Use `build()` function standing on X marks, facing empty lots:
```python
player.build(big_green_house)    # Builds big green house
player.build(small_blue_house)   # Builds small blue house
player.build(big_orange_house)   # Builds big orange house
player.build(small_red_house)    # Builds small red house
```

Game reads object properties to determine house appearance.

**Key Teaching Point**: Class attributes (properties) store object-specific data. Set in `__init__`, accessed with `object.attribute`. Same class, different property values â†’ different objects. Properties make objects customizable."
"Chapter 9, Level 4",Class Methods (Custom Functions in Classes),Call refill() method on machine object to refill food or water.,"Level 4: activate pumps to refill water and food for cows in stable. Game provides `machine` class with `refill()` function:

```python
class Machine:
    def refill(self, resource):
        if resource == ""food"":
            # Refill food logic
            pump_food()
        elif resource == ""water"":
            # Refill water logic
            pump_water()
```

Class has method (function) that takes `resource` argument (`""food""` or `""water""`). First, create object reference:

```python
pump = Machine()  # Create machine object
```

Walk to four X marks. On dark X marks, call function to refill food:
```python
pump.refill(""food"")
```

On light X marks, call function to refill water:
```python
pump.refill(""water"")
```

Method called with `object.method_name(arguments)` syntax. Same object, different arguments â†’ different behaviors.

Use class object's function on all four X marks to complete level.

**Key Teaching Point**: Class methods are functions inside classes. First parameter is `self` (the object). Called with `object.method()` syntax. Methods can access object's properties and perform actions. Objects encapsulate both data (properties) and behavior (methods)."
