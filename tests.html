<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Tests - Python Learning Platform</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #fff;
            padding: 20px;
        }

        .test-header {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border: 2px solid #444;
        }

        .test-header h1 {
            color: #7fc542;
            margin-bottom: 10px;
        }

        .test-category {
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .category-header {
            background: #3a3a3a;
            padding: 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .category-header:hover {
            background: #4a4a4a;
        }

        .category-header h2 {
            color: #7fc542;
            font-size: 18px;
        }

        .test-count {
            background: #555;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 14px;
        }

        .test-results {
            padding: 20px;
            display: none;
        }

        .test-results.active {
            display: block;
        }

        .test-item {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-name {
            flex: 1;
            margin-right: 20px;
        }

        .test-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-pass {
            background: #4caf50;
            color: #000;
        }

        .status-fail {
            background: #f44336;
            color: #fff;
        }

        .status-running {
            background: #ff9800;
            color: #000;
        }

        .status-pending {
            background: #555;
            color: #ccc;
        }

        .test-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            background: #7fc542;
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 3px 0 #5da030;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 0 #5da030;
        }

        .control-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 0 #5da030;
        }

        .control-btn.stop {
            background: #f44336;
            box-shadow: 0 3px 0 #d32f2f;
        }

        .control-btn.stop:hover {
            box-shadow: 0 5px 0 #d32f2f;
        }

        .control-btn.stop:active {
            box-shadow: 0 2px 0 #d32f2f;
        }

        .test-output {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            white-space: pre-wrap;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }

        .test-output.show {
            display: block;
        }

        .test-summary {
            background: #3a3a3a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
            display: none;
        }

        .test-summary.show {
            display: block;
        }

        .summary-stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .stat-item {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #999;
        }

        /* Test-specific styles */
        #test-canvas {
            border: 2px solid #444;
            display: none;
            margin: 20px 0;
        }

        .modal-test {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #7fc542;
            padding: 20px;
            border-radius: 8px;
            display: none;
            z-index: 10000;
        }

        .editor-test {
            background: #1a1a1a;
            border: 2px solid #444;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            min-height: 100px;
        }
    </style>
</head>
<body>
    <div class="test-header">
        <h1>ðŸ§ª System Test Suite</h1>
        <p>Comprehensive testing for Python Learning Platform components</p>
    </div>

    <!-- Tutor System Tests -->
    <div class="test-category" id="tutor-tests">
        <div class="category-header" onclick="toggleCategory('tutor-tests')">
            <h2>1. Rules-Based Tutor System</h2>
            <span class="test-count">0/5 tests</span>
        </div>
        <div class="test-results" id="tutor-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- AI Tutor Tests -->
    <div class="test-category" id="ai-tutor-tests">
        <div class="category-header" onclick="toggleCategory('ai-tutor-tests')">
            <h2>2. AI Tutor System</h2>
            <span class="test-count">0/4 tests</span>
        </div>
        <div class="test-results" id="ai-tutor-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- Code Execution Tests -->
    <div class="test-category" id="code-execution-tests">
        <div class="category-header" onclick="toggleCategory('code-execution-tests')">
            <h2>3. Code Execution & Parsing</h2>
            <span class="test-count">0/6 tests</span>
        </div>
        <div class="test-results" id="code-execution-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- Level Progression Tests -->
    <div class="test-category" id="level-progression-tests">
        <div class="category-header" onclick="toggleCategory('level-progression-tests')">
            <h2>4. Level Progression & State</h2>
            <span class="test-count">0/5 tests</span>
        </div>
        <div class="test-results" id="level-progression-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- Map Rendering Tests -->
    <div class="test-category" id="map-rendering-tests">
        <div class="category-header" onclick="toggleCategory('map-rendering-tests')">
            <h2>5. Map Rendering & Game State</h2>
            <span class="test-count">0/5 tests</span>
        </div>
        <div class="test-results" id="map-rendering-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- File Loading Tests -->
    <div class="test-category" id="file-loading-tests">
        <div class="category-header" onclick="toggleCategory('file-loading-tests')">
            <h2>6. File Loading & Markdown</h2>
            <span class="test-count">0/4 tests</span>
        </div>
        <div class="test-results" id="file-loading-tests-results">
            <!-- Tests will be added dynamically -->
        </div>
    </div>

    <!-- Test Summary -->
    <div class="test-summary" id="test-summary">
        <h3>Test Summary</h3>
        <div class="summary-stats">
            <div class="stat-item">
                <div class="stat-value" style="color: #4caf50;" id="passed-count">0</div>
                <div class="stat-label">Passed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" style="color: #f44336;" id="failed-count">0</div>
                <div class="stat-label">Failed</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" style="color: #ff9800;" id="total-count">0</div>
                <div class="stat-label">Total</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="time-taken">0ms</div>
                <div class="stat-label">Time</div>
            </div>
        </div>
    </div>

    <!-- Control Buttons -->
    <div class="test-controls">
        <button class="control-btn" onclick="runAllTests()">â–¶ Run All Tests</button>
        <button class="control-btn stop" onclick="stopTests()">â–  Stop Tests</button>
        <button class="control-btn" onclick="clearResults()">â†º Clear Results</button>
        <button class="control-btn" onclick="testTutorDialog()">ðŸŽ“ Test Tutor Dialog</button>
    </div>

    <!-- Hidden test elements -->
    <canvas id="test-canvas" width="512" height="352"></canvas>
    <div class="editor-test" id="test-editor"></div>
    <div class="modal-test" id="test-modal"></div>

    <!-- Load dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Load main application scripts for testing -->
    <script src="js/coding-tutor.js"></script>
    <script src="js/code-execution.js"></script>
    
    <!-- Test Scripts -->
    <script>
        // Test Framework
        class TestRunner {
            constructor() {
                this.tests = {};
                this.results = {};
                this.isRunning = false;
                this.startTime = 0;
            }

            addTest(category, name, testFn) {
                if (!this.tests[category]) {
                    this.tests[category] = [];
                }
                this.tests[category].push({ name, testFn });
            }

            async runTest(category, test) {
                const testId = `${category}-${test.name}`;
                this.updateTestStatus(testId, 'running');
                
                try {
                    const result = await test.testFn();
                    this.updateTestStatus(testId, result ? 'pass' : 'fail', result);
                    return result;
                } catch (error) {
                    console.error(`Test failed: ${test.name}`, error);
                    this.updateTestStatus(testId, 'fail', error.message);
                    return false;
                }
            }

            updateTestStatus(testId, status, message = '') {
                const element = document.getElementById(testId);
                if (element) {
                    const statusEl = element.querySelector('.test-status');
                    statusEl.className = `test-status status-${status}`;
                    statusEl.textContent = status;
                    
                    // Add output if there's a message
                    if (message && status === 'fail') {
                        let output = element.querySelector('.test-output');
                        if (!output) {
                            output = document.createElement('div');
                            output.className = 'test-output';
                            element.appendChild(output);
                        }
                        output.textContent = `Error: ${message}`;
                        output.classList.add('show');
                    }
                }
                
                this.results[testId] = status;
            }

            async runAllTests() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.results = {};
                this.startTime = Date.now();
                
                for (const [category, tests] of Object.entries(this.tests)) {
                    for (const test of tests) {
                        if (!this.isRunning) break;
                        await this.runTest(category, test);
                        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay between tests
                    }
                }
                
                this.showSummary();
                this.isRunning = false;
            }

            showSummary() {
                const summary = document.getElementById('test-summary');
                const passed = Object.values(this.results).filter(r => r === 'pass').length;
                const failed = Object.values(this.results).filter(r => r === 'fail').length;
                const total = Object.keys(this.results).length;
                const time = Date.now() - this.startTime;
                
                document.getElementById('passed-count').textContent = passed;
                document.getElementById('failed-count').textContent = failed;
                document.getElementById('total-count').textContent = total;
                document.getElementById('time-taken').textContent = `${time}ms`;
                
                summary.classList.add('show');
            }

            stop() {
                this.isRunning = false;
            }
        }

        const testRunner = new TestRunner();

        // Initialize test UI
        function initializeTests() {
            // 1. Rules-Based Tutor Tests
            const tutorTests = [
                { name: 'test-simple-recommendation', display: 'Simple recommendation generation' },
                { name: 'test-incorrect-line-detection', display: 'Incorrect line detection' },
                { name: 'test-apply-recommendation', display: 'Apply recommendation to code' },
                { name: 'test-multiple-errors', display: 'Multiple errors trigger AI' },
                { name: 'test-incomplete-code', display: 'Incomplete code suggestions' }
            ];
            
            renderTests('tutor-tests', tutorTests);
            
            // 2. AI Tutor Tests
            const aiTutorTests = [
                { name: 'test-ai-context', display: 'AI understands solution constraints' },
                { name: 'test-ai-simple-commands', display: 'AI suggests only available commands' },
                { name: 'test-ai-response-format', display: 'AI returns correct JSON format' },
                { name: 'test-ai-fallback', display: 'AI fallback when API unavailable' }
            ];
            
            renderTests('ai-tutor-tests', aiTutorTests);
            
            // 3. Code Execution Tests
            const codeTests = [
                { name: 'test-parse-commands', display: 'Parse movement commands' },
                { name: 'test-execute-sequence', display: 'Execute command sequence' },
                { name: 'test-invalid-syntax', display: 'Handle invalid syntax' },
                { name: 'test-normalize-code', display: 'Normalize code format' },
                { name: 'test-import-handling', display: 'Handle import statements' },
                { name: 'test-command-validation', display: 'Validate command existence' }
            ];
            
            renderTests('code-execution-tests', codeTests);
            
            // 4. Level Progression Tests
            const levelTests = [
                { name: 'test-level-completion', display: 'Level completion detection' },
                { name: 'test-progress-tracking', display: 'Progress indicator updates' },
                { name: 'test-level-navigation', display: 'Navigate between levels' },
                { name: 'test-state-persistence', display: 'State persistence in localStorage' },
                { name: 'test-reset-functionality', display: 'Reset game state' }
            ];
            
            renderTests('level-progression-tests', levelTests);
            
            // 5. Map Rendering Tests
            const mapTests = [
                { name: 'test-map-parsing', display: 'Parse map from markdown' },
                { name: 'test-tile-rendering', display: 'Render tiles correctly' },
                { name: 'test-character-positioning', display: 'Character spawn position' },
                { name: 'test-collision-detection', display: 'Wall collision detection' },
                { name: 'test-goal-detection', display: 'Goal reached detection' }
            ];
            
            renderTests('map-rendering-tests', mapTests);
            
            // 6. File Loading Tests
            const fileTests = [
                { name: 'test-markdown-parsing', display: 'Parse markdown structure' },
                { name: 'test-extract-code-blocks', display: 'Extract code blocks' },
                { name: 'test-level-extraction', display: 'Extract level data' },
                { name: 'test-map-extraction', display: 'Extract map from markdown' }
            ];
            
            renderTests('file-loading-tests', fileTests);
        }

        function renderTests(categoryId, tests) {
            const container = document.getElementById(`${categoryId}-results`);
            container.innerHTML = '';
            
            tests.forEach(test => {
                const testDiv = document.createElement('div');
                testDiv.className = 'test-item';
                testDiv.id = `${categoryId}-${test.name}`;
                testDiv.innerHTML = `
                    <span class="test-name">${test.display}</span>
                    <span class="test-status status-pending">pending</span>
                `;
                container.appendChild(testDiv);
            });
            
            // Update count
            const header = document.querySelector(`#${categoryId} .test-count`);
            header.textContent = `0/${tests.length} tests`;
        }

        function toggleCategory(categoryId) {
            const results = document.getElementById(`${categoryId}-results`);
            results.classList.toggle('active');
        }

        // Test implementations
        function setupTests() {
            // Load required scripts first
            loadTestDependencies().then(() => {
                // 1. Rules-Based Tutor Tests
                testRunner.addTest('tutor-tests', 'test-simple-recommendation', async () => {
                    const studentCode = 'player.move_forward()';
                    const solutionCode = 'player.move_forward()\nplayer.turn_left()';
                    const result = testRecommendation(studentCode, solutionCode);
                    return result && result.type === 'incomplete';
                });
                
                testRunner.addTest('tutor-tests', 'test-incorrect-line-detection', async () => {
                    const studentCode = 'player.move_forward()\nplayer.turn_right()';
                    const solutionCode = 'player.move_forward()\nplayer.turn_left()';
                    const result = testRecommendation(studentCode, solutionCode);
                    return result && result.type === 'incorrect' && result.lineNumber === 2;
                });
                
                testRunner.addTest('tutor-tests', 'test-apply-recommendation', async () => {
                    // Test that apply functionality works
                    return testApplyRecommendation();
                });
                
                testRunner.addTest('tutor-tests', 'test-multiple-errors', async () => {
                    const studentCode = 'player.turn_right()\nplayer.turn_right()\nplayer.turn_right()';
                    const solutionCode = 'player.move_forward()\nplayer.turn_left()\nplayer.move_forward()';
                    const result = testRecommendation(studentCode, solutionCode);
                    return result && result.needsAI === true;
                });
                
                testRunner.addTest('tutor-tests', 'test-incomplete-code', async () => {
                    const studentCode = 'player.move_forward()';
                    const solutionCode = 'player.move_forward()\nplayer.move_forward()\nplayer.move_forward()';
                    const result = testRecommendation(studentCode, solutionCode);
                    return result && result.type === 'incomplete';
                });
                
                // 2. AI Tutor Tests
                testRunner.addTest('ai-tutor-tests', 'test-ai-context', async () => {
                    // Test that AI prompt includes solution code
                    return testAIContext();
                });
                
                testRunner.addTest('ai-tutor-tests', 'test-ai-simple-commands', async () => {
                    // Test that AI only suggests available commands
                    return testAICommandConstraints();
                });
                
                testRunner.addTest('ai-tutor-tests', 'test-ai-response-format', async () => {
                    // Test JSON response format
                    return testAIResponseFormat();
                });
                
                testRunner.addTest('ai-tutor-tests', 'test-ai-fallback', async () => {
                    // Test fallback when API key missing
                    return testAIFallback();
                });
                
                // 3. Code Execution Tests
                testRunner.addTest('code-execution-tests', 'test-parse-commands', async () => {
                    return testParseCommands();
                });
                
                testRunner.addTest('code-execution-tests', 'test-execute-sequence', async () => {
                    return testExecuteSequence();
                });
                
                testRunner.addTest('code-execution-tests', 'test-invalid-syntax', async () => {
                    return testInvalidSyntax();
                });
                
                testRunner.addTest('code-execution-tests', 'test-normalize-code', async () => {
                    return testNormalizeCode();
                });
                
                testRunner.addTest('code-execution-tests', 'test-import-handling', async () => {
                    return testImportHandling();
                });
                
                testRunner.addTest('code-execution-tests', 'test-command-validation', async () => {
                    return testCommandValidation();
                });
                
                // 4. Level Progression Tests
                testRunner.addTest('level-progression-tests', 'test-level-completion', async () => {
                    return testLevelCompletion();
                });
                
                testRunner.addTest('level-progression-tests', 'test-progress-tracking', async () => {
                    return testProgressTracking();
                });
                
                testRunner.addTest('level-progression-tests', 'test-level-navigation', async () => {
                    return testLevelNavigation();
                });
                
                testRunner.addTest('level-progression-tests', 'test-state-persistence', async () => {
                    return testStatePersistence();
                });
                
                testRunner.addTest('level-progression-tests', 'test-reset-functionality', async () => {
                    return testResetFunctionality();
                });
                
                // 5. Map Rendering Tests
                testRunner.addTest('map-rendering-tests', 'test-map-parsing', async () => {
                    return testMapParsing();
                });
                
                testRunner.addTest('map-rendering-tests', 'test-tile-rendering', async () => {
                    return testTileRendering();
                });
                
                testRunner.addTest('map-rendering-tests', 'test-character-positioning', async () => {
                    return testCharacterPositioning();
                });
                
                testRunner.addTest('map-rendering-tests', 'test-collision-detection', async () => {
                    return testCollisionDetection();
                });
                
                testRunner.addTest('map-rendering-tests', 'test-goal-detection', async () => {
                    return testGoalDetection();
                });
                
                // 6. File Loading Tests
                testRunner.addTest('file-loading-tests', 'test-markdown-parsing', async () => {
                    return testMarkdownParsing();
                });
                
                testRunner.addTest('file-loading-tests', 'test-extract-code-blocks', async () => {
                    return testExtractCodeBlocks();
                });
                
                testRunner.addTest('file-loading-tests', 'test-level-extraction', async () => {
                    return testLevelExtraction();
                });
                
                testRunner.addTest('file-loading-tests', 'test-map-extraction', async () => {
                    return testMapExtraction();
                });
            });
        }

        // Load dependencies
        async function loadTestDependencies() {
            // Load necessary functions from main application
            return new Promise((resolve) => {
                // Mock or load actual functions
                window.testMode = true;
                resolve();
            });
        }

        // Test implementation functions
        function testRecommendation(studentCode, solutionCode) {
            // Mock the generateRecommendation function
            const normalizeCode = (code) => {
                return code.split('\n')
                    .map(line => line.trim())
                    .filter(line => line && !line.startsWith('#') && !line.startsWith('import'));
            };
            
            const studentLines = normalizeCode(studentCode);
            const solutionLines = normalizeCode(solutionCode);
            
            // Simple implementation for testing
            if (studentLines.length < solutionLines.length) {
                return {
                    type: 'incomplete',
                    message: 'Add more commands',
                    code: solutionLines[studentLines.length]
                };
            }
            
            let incorrectCount = 0;
            let firstIncorrectIndex = -1;
            
            for (let i = 0; i < studentLines.length; i++) {
                if (studentLines[i] !== solutionLines[i]) {
                    incorrectCount++;
                    if (firstIncorrectIndex === -1) {
                        firstIncorrectIndex = i;
                    }
                }
            }
            
            if (incorrectCount > 2) {
                return { needsAI: true };
            }
            
            if (firstIncorrectIndex >= 0) {
                return {
                    type: 'incorrect',
                    lineNumber: firstIncorrectIndex + 1,
                    message: `Change line ${firstIncorrectIndex + 1}`,
                    code: solutionLines[firstIncorrectIndex]
                };
            }
            
            return null;
        }

        function testApplyRecommendation() {
            // Test apply functionality
            const testCode = 'player.move_forward()';
            const recommendation = {
                type: 'incomplete',
                code: 'player.turn_left()'
            };
            
            // Simulate applying
            const lines = testCode.split('\n');
            lines.push(recommendation.code);
            const result = lines.join('\n');
            
            return result === 'player.move_forward()\nplayer.turn_left()';
        }

        function testAIContext() {
            // Check if AI prompt includes solution code
            const prompt = `The solution code below shows exactly what's available at this level`;
            return prompt.includes('solution code');
        }

        function testAICommandConstraints() {
            // Test command constraints
            const availableCommands = ['player.move_forward()', 'player.turn_left()'];
            const suggestion = 'player.move_forward()';
            return availableCommands.some(cmd => suggestion.includes(cmd.split('(')[0]));
        }

        function testAIResponseFormat() {
            // Test JSON format validation
            const response = { message: 'Test message', code: 'player.move_forward()' };
            return response.message && response.code;
        }

        function testAIFallback() {
            // Test fallback behavior
            const fallback = { message: 'Try adding more movement commands', code: 'player.move_forward()' };
            return fallback.message && fallback.code;
        }

        function testParseCommands() {
            const code = 'player.move_forward()\nplayer.turn_left()';
            const commands = code.split('\n').filter(line => line.trim());
            return commands.length === 2;
        }

        function testExecuteSequence() {
            const commands = ['move_forward', 'turn_left', 'move_forward'];
            let position = { x: 0, y: 0, direction: 'right' };
            
            // Simulate execution
            commands.forEach(cmd => {
                if (cmd === 'move_forward') {
                    if (position.direction === 'right') position.x++;
                } else if (cmd === 'turn_left') {
                    position.direction = 'up';
                }
            });
            
            return position.x === 1 && position.direction === 'up';
        }

        function testInvalidSyntax() {
            const invalidCode = 'player.invalid_command()';
            try {
                // Should detect invalid command
                const valid = ['move_forward', 'turn_left', 'turn_right'];
                const command = invalidCode.match(/player\.(\w+)/)[1];
                return !valid.includes(command);
            } catch {
                return true;
            }
        }

        function testNormalizeCode() {
            const code = '  player.move_forward()  \n\n  player.turn_left()  ';
            const normalized = code.split('\n')
                .map(line => line.trim())
                .filter(line => line)
                .join('\n');
            return normalized === 'player.move_forward()\nplayer.turn_left()';
        }

        function testImportHandling() {
            const code = 'import player\nplayer.move_forward()';
            const filtered = code.split('\n')
                .filter(line => !line.startsWith('import'))
                .join('\n');
            return filtered === 'player.move_forward()';
        }

        function testCommandValidation() {
            const validCommands = ['player.move_forward()', 'player.turn_left()', 'player.turn_right()'];
            const testCommand = 'player.move_forward()';
            return validCommands.includes(testCommand);
        }

        function testLevelCompletion() {
            // Test level completion logic
            const goalPos = { x: 5, y: 5 };
            const playerPos = { x: 5, y: 5 };
            return goalPos.x === playerPos.x && goalPos.y === playerPos.y;
        }

        function testProgressTracking() {
            // Test progress indicators
            const completed = [true, true, false, false];
            const progress = completed.filter(c => c).length / completed.length;
            return progress === 0.5;
        }

        function testLevelNavigation() {
            // Test level navigation
            let currentLevel = 0;
            const maxLevel = 5;
            currentLevel++;
            return currentLevel === 1 && currentLevel < maxLevel;
        }

        function testStatePersistence() {
            // Test localStorage
            localStorage.setItem('test-key', 'test-value');
            const value = localStorage.getItem('test-key');
            localStorage.removeItem('test-key');
            return value === 'test-value';
        }

        function testResetFunctionality() {
            // Test reset
            let state = { position: { x: 5, y: 5 } };
            const initialState = { position: { x: 0, y: 0 } };
            state = { ...initialState };
            return state.position.x === 0 && state.position.y === 0;
        }

        function testMapParsing() {
            const mapData = `
                #####
                #S..#
                #...#
                #..G#
                #####
            `;
            const lines = mapData.trim().split('\n').map(l => l.trim());
            return lines.length === 5 && lines[0].length === 5;
        }

        function testTileRendering() {
            // Test tile rendering logic
            const tileSize = 32;
            const x = 2;
            const y = 3;
            const pixelX = x * tileSize;
            const pixelY = y * tileSize;
            return pixelX === 64 && pixelY === 96;
        }

        function testCharacterPositioning() {
            const map = ['#S#', '#.#', '#G#'];
            let startPos = null;
            
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 'S') {
                        startPos = { x, y };
                        break;
                    }
                }
            }
            
            return startPos && startPos.x === 1 && startPos.y === 0;
        }

        function testCollisionDetection() {
            const map = ['###', '#.#', '###'];
            const isWall = (x, y) => {
                return map[y] && map[y][x] === '#';
            };
            return isWall(0, 0) && !isWall(1, 1);
        }

        function testGoalDetection() {
            const map = ['#S#', '#.#', '#G#'];
            let goalPos = null;
            
            for (let y = 0; y < map.length; y++) {
                for (let x = 0; x < map[y].length; x++) {
                    if (map[y][x] === 'G') {
                        goalPos = { x, y };
                        break;
                    }
                }
            }
            
            return goalPos && goalPos.x === 1 && goalPos.y === 2;
        }

        function testMarkdownParsing() {
            const markdown = '# Title\n\nSome content\n\n```python\ncode\n```';
            const hasTitle = markdown.includes('# Title');
            const hasCode = markdown.includes('```python');
            return hasTitle && hasCode;
        }

        function testExtractCodeBlocks() {
            const markdown = '```python\nplayer.move_forward()\n```';
            const codeMatch = markdown.match(/```python\n([\s\S]*?)\n```/);
            return codeMatch && codeMatch[1] === 'player.move_forward()';
        }

        function testLevelExtraction() {
            const markdown = '<!-- LEVEL START -->\nContent\n<!-- LEVEL END -->';
            const levelMatch = markdown.includes('LEVEL START') && markdown.includes('LEVEL END');
            return levelMatch;
        }

        function testMapExtraction() {
            const markdown = '```map\n#S#\n#.#\n#G#\n```';
            const mapMatch = markdown.match(/```map\n([\s\S]*?)\n```/);
            return mapMatch && mapMatch[1].includes('S') && mapMatch[1].includes('G');
        }

        // UI Functions
        function runAllTests() {
            clearResults();
            testRunner.runAllTests();
        }

        function stopTests() {
            testRunner.stop();
        }

        function clearResults() {
            document.getElementById('test-summary').classList.remove('show');
            document.querySelectorAll('.test-status').forEach(el => {
                el.className = 'test-status status-pending';
                el.textContent = 'pending';
            });
            document.querySelectorAll('.test-output').forEach(el => {
                el.classList.remove('show');
            });
        }

        function testTutorDialog() {
            // Create a mock tutor dialog for testing
            const modal = document.getElementById('test-modal');
            modal.innerHTML = `
                <h3>ðŸŽ“ Test Tutor Dialog</h3>
                <p style="background: #735a9e; color: white; padding: 10px; border-radius: 4px;">
                    This is a test of the tutor dialog system.
                </p>
                <div style="background: #1a1a1a; color: #7fc542; padding: 10px; margin: 10px 0;">
                    player.move_forward()
                </div>
                <button onclick="this.parentElement.style.display='none'" style="background: #8bc34a; padding: 8px 16px; border: none; cursor: pointer;">
                    APPLY
                </button>
            `;
            modal.style.display = 'block';
        }

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            initializeTests();
            setupTests();
        });
    </script>
</body>
</html>